\documentclass[14pt,a4paper,russian]{extreport}
%===========================================
\usepackage{geometry} 
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage[russian,english]{babel}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{titlesec}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{tabularx}
\usepackage{setspace}
%===========================================

%===========================================
\setlength{\parindent}{1.25cm}
\linespread{1.5}

\geometry{
    a4paper,
    total={170mm,257mm},
    top=20mm,
    right=15mm,
    left=25mm
}

\hypersetup{
    citecolor=black,
    filecolor=black,
    linktoc=all,
}

\titleformat{\chapter}{\normalfont\large\bfseries\filcenter}{Глава \thechapter}{1em}{}\titlespacing*{\chapter}{0pt}{-43pt}{19pt}

\titleformat{\section}{\normalfont\large\bfseries\filcenter}{\thesection}{1em}{}
\titleformat{\subsection}{\normalfont\bfseries\filcenter}{\thesubsection}{1em}{}
    
\setlist[itemize]{noitemsep, topsep=0pt}
\setlist[enumerate]{noitemsep, topsep=0pt}

\graphicspath{ {./images/} }

\bibliographystyle{gost71u} 

\let\oldtabularx\tabularx 
\renewcommand{\tabularx}{\small\oldtabularx}


\captionsetup[figure]{labelformat=simple, labelsep=space}
\captionsetup[table]{labelformat=simple, labelsep=space, justification=raggedleft, singlelinecheck=false, skip=10pt}
\captionsetup[subtable]{labelformat=empty, labelsep=space, justification=centering, singlelinecheck=false}
\captionsetup[lstlisting]{labelformat=simple, labelsep=space, justification=raggedright, singlelinecheck=false}
%===========================================


\begin{document}

%==============START TITLEPAGE=============
\begin{titlepage}
    \centering
    \begin{figure}
        \center\includegraphics[width=4cm]{stankin.png}
    \end{figure}
    \begin{small}
    \textbf {МИНОБРНАУКИ РОССИИ}\par
    {\textbf{федеральное государственное бюджетное образовательное \\учреждение
    высшего образования\\
     «Московский государственный технологический университет «СТАНКИН»\\
     (ФГБОУ ВО МГТУ «СТАНКИН»)}}\par
\hrulefill\par
     {\textbf{Институт}}\hfill{\textbf{Кафедра\phantom{--00000000000-0--}}}\\
     информационных систем и технологий\hfillинформационных систем\phantom{---0-}\\
    \vspace{1cm} 
    {\textbf {Отчёт по лабораторной работе}\par}
    {по дисциплине {\textbf{«Теория информационных систем и процессов»}}\par}
    на тему: \textbf{Алгоритм сжатия Хаффмана}
    \vspace{5cm}
    \begin{flushleft}
        {\textbf{Студент}  \hfill \rule{2cm}{0.4pt}\phantom{00}Махмудов Б.Н.\phantom{-0}}\par
        {группа ИДБ-16-07\hfill
        \footnotesize{подпись}\phantom{00000000000000000000000}}\par
        \vspace{1cm}
        {\textbf{Преподаватель}\hfill \rule{2cm}{0.4pt}\phantom{00}Охотников В.А.}\par
		{\phantom{000000000000}\hfill
        \footnotesize{подпись}\phantom{00000000000000000000000}}\par
    \end{flushleft} 
    {\vfill Москва 2019}
    \end{small}
\end{titlepage}
%==============END TITLEPAGE=============

\addtocounter{page}{1}

\selectlanguage{russian}

\sloppy

\chapter{Программа сжатия данных используя алгоритм Хаффмана}

\begin{figure}[h!]
        \includegraphics[width=\textwidth]{mode}
		\caption{Выбор режима работы программы}
        \label{fig:medcvisemp}
\end{figure}
\begin{figure}[h!]
        \includegraphics[width=\textwidth]{interactive_inp}
        \caption{Ввод данных в интерактивном режиме}
        \label{fig:medcvisemp}
\end{figure}

\begin{figure}[h!]
        \includegraphics[width=\textwidth]{interactive_table}
		\caption{Вывод таблицы префикс кодов после обработки ввода (интерактивный режим)}
        \label{fig:medcvisemp}
\end{figure}

\begin{figure}[h!]
        \includegraphics[width=\textwidth]{filerequest}
		\caption{Запрос файла для кодирования и декодирования или наоборот (зависит от режима)}
        \label{fig:medcvisemp}
\end{figure}

\begin{figure}[h!]
        \includegraphics[width=\textwidth]{fileiotable}
		\caption{Вывод таблицы префикс кодов после обработки файла (режима ввода/вывода из файла)}
        \label{fig:medcvisemp}
\end{figure}

\cleardoublepage
\begin{verbatim}
#define CODIFY
#include <haffman.h>

//функция для вычисления префикс кодов 
void codify(CODETABLE table) 
{
	//размер очереди (используется в дальнейшем)
	int qsz = table->distcharc; 
	int mintreedepth = 1;
	CODEVALUE sorted[table->distcharc];
	int min = 1, bp; //bp - для вставки в очередь нового эл-та

/*после окончания цикла получим
полностью отсортированную очередь*/
	for (int i = 0; i < qsz; ) { 
		for (int j = 0; j < qsz; ++j)
			if (table->codes[j].occurence == min) {
				sorted[i].value = table->codes[j].value;
				sorted[i++].occurence = table->codes[j].occurence;
			}
		++min;
	}
	CODENODE *queue = malloc(sizeof(CODENODE) * qsz); //очередь
/*baseline имеет точную копию очереди до начала работы алгоритма, 
 * также каждый элемент baseline имееет ссылку на элемент из массива
 * codes в таблице кодов*/
	CODENODE baseline = malloc(sizeof(struct codenode) * qsz);
	CODENODE temp; //указатель на побегушках
	for (int i = 0; i < table->distcharc; ++i) {
		baseline[i].weight = sorted[i].occurence;
		baseline[i].origin = &sorted[i];
		queue[i] = &baseline[i];	
	}
/*начало работы алгоритма, вся суть которого получить бинарное дерево
 * алгоритм использует сортируемую очередь для получения оптимальных 
 * префикс кодов*/
	while (qsz > 1) {
		temp = malloc(sizeof(struct codenode));	
		temp->weight = queue[0]->weight + queue[1]->weight;
		temp->parent = NULL;
		queue[0]->parent = queue[1]->parent = temp;	
		queue[0]->dirctn = '0';
		queue[1]->dirctn = '1';

		for (int i = 0; i < qsz - 2; ++i) {
			queue[i] = queue[i + 2]; //двигаем элементы на 2 влево
		}
		//сжимаем очередь
		queue = realloc(queue, sizeof(CODENODE) * (--qsz)); 
		//находим место для вставки нового элемента
		for (bp = 0; (bp < qsz - 1) && 
			(queue[bp]->weight < temp->weight); ++bp); 
		for (int i = 0; i < (qsz - bp - 1); ++i)
			queue[qsz - 1 - i] = queue[qsz - 2 - i];//подвиньтесь!
		queue[bp] = temp; //вставляем
	}
	/*сборка кодов, начинаем снизу с каждого элемента baseline,
	 * оттуда движемся вверх используя указатели до корня,
	 * в результате получим перевернутый префикс код*/
	char t[100] = {0}; //времменный буффер для сборки кода
	for (int i = 0, j = 0; i < table->distcharc; ++i) {
		temp = &baseline[i];
		for (j = 0; temp->parent; j++) {
			t[j] = temp->dirctn; 
			temp = temp->parent;
		}
		t[j] = 0;
		/*mintreedepth мета информация касательно минимальной глубины дерева,
		 * данная информация существенно ускоряет процесс декодирования в 
		 * дальнейшем*/
		mintreedepth = (mintreedepth < j) ? mintreedepth : j;	
		strreverse(t); //переворачиваем строку
		baseline[i].origin->prefixc = malloc(strlen(t) + 1);
		//codelen мета-информация для записи таблицы в файл
		baseline[i].origin->codelen = strlen(t);
		/*кладем полученный код в таблицу */
		strcpy(baseline[i].origin->prefixc, t);
		memset(t, 0, 100);
	}
	for (int i = 0, j = 0; i < table->distcharc; ++i) {
		while (sorted[j++].value != table->codes[i].value);
		table->codes[i].prefixc = sorted[--j].prefixc;
		table->codes[i].codelen = sorted[j].codelen;
		j = 0;
	}
	table->mintreedepth = mintreedepth;
	free(queue);
	free(baseline);
}
\end{verbatim}
\begin{verbatim}
/*pathnode используется при декодирования 
 * является узлом древа поиска, которое
 * формируется используя таблицу кодов
 * данный подход снизил время декодирования
 * в 5 раз*/

typedef struct pathnode {
	wchar_t value;
	struct pathnode *child[2];
} *PATHNODE;

/*Основная структура содержащие данные о кодах 
 * и символах*/
typedef struct codevalue {
	wchar_t value;
	unsigned int occurence;
	double distribution;
	short codelen;
	char *prefixc;
} CODEVALUE;

/*Мастер структура*/
typedef struct codetable { 
	unsigned int totcharc;
	unsigned int distcharc;
	unsigned int tablesize;
	unsigned int mintreedepth; 
	CODEVALUE codes[];
} *CODETABLE;

/*Используется при формировании префиксного дерева*/
typedef struct codenode {
	unsigned int weight;
	unsigned char dirctn;
	struct codenode *parent;
	CODEVALUE *origin;
} *CODENODE;

\end{verbatim}

\begin{verbatim}
#include <haffman.h>

/*Кладёт таблицу префикс кодов
 * со всем содержим в файл, кладет как есть
 * в бинарном виде*/
void filedump(CODETABLE table, FILE *out)
{
	fwrite(table, table->tablesize, 1, out);
	for (int i = 0; i < table->distcharc; ++i)
		fwrite(table->codes[i].prefixc, table->codes[i].codelen, 1, out);
}


/*Вынимает таблицу которую положил filedump*/
CODETABLE fileextract(FILE *in)
{
	unsigned int tsz;
	CODETABLE table = malloc(sizeof(struct codetable));
	fread(table, sizeof(struct codetable), 1, in);
	tsz = table->tablesize;
	free(table);
	rewind(in);
	table = malloc(tsz);	
	fread(table, tsz, 1, in);
	for (int i = 0; i < table->distcharc; ++i) {
		table->codes[i].prefixc = malloc(table->codes[i].codelen + 1);
		fread(table->codes[i].prefixc, table->codes[i].codelen, 1, in);
		table->codes[i].prefixc[table->codes[i].codelen] = 0;
	}
	return table;
}
\end{verbatim}

\begin{verbatim}
#define UTILITY
#include <haffman.h>
/*gettable берёт источник символов (файл или строка)
 * читает её заполняет codetable всей информацией кроме
 * кроме кодов*/
CODETABLE gettable(void *textsource, M mode)	
{
	CODETABLE table;
	unsigned int dcount = 0, tcount = 0, tsz;
	int val, occs[256] = {0}; //occurrences
	wchar_t temp[256] = {0};
	wchar_t *hit;
	switch (mode) {
		case FILE_S:
			;
			FILE *fptr = (FILE *)textsource;
			while ((val = fgetwc(fptr)) != WEOF) {
				if (!(hit = wcschr(temp, val))) {
					temp[dcount] = val;
					++occs[dcount];
					++dcount;
				}
				else
					++(occs[hit - temp]);
				++tcount;
			}
			break;
		case STRING_S:
			;
			wchar_t *cptr = (wchar_t *)textsource;
			for (int i = 0; cptr[i] != '\0'; ++i) {
				if (!(hit = wcschr(temp, cptr[i]))) {
					temp[dcount] = cptr[i];
					++occs[dcount];
					++dcount;
					}
				else
					++(occs[hit - temp]);
				++tcount;
			}
			break;
	}

	table = malloc(tsz = (sizeof(*table) + sizeof(struct codevalue) * wcslen(temp)));
	table->totcharc = tcount; 
	table->distcharc = wcslen(temp);
	table->tablesize = tsz;

	for (int i = 0; i < table->distcharc; ++i) {
		table->codes[i].value = temp[i];
		table->codes[i].occurence = occs[i];
		table->codes[i].distribution = occs[i] / (double)tcount;
	}
		
	return table;
}

/*spush, spop, treedelete функции для поддержания чистоты*/
void spush(PATHNODE **stack, int *stsz, PATHNODE node)
{
    *stack = realloc(*stack, sizeof(PATHNODE) * (++(*stsz)));
    (*stack)[*stsz - 1] = node;
}

PATHNODE spop(PATHNODE **stack, int *stsz)
{
    PATHNODE temp = (*stack)[*stsz - 1];
    *stack = realloc(*stack, sizeof(PATHNODE) * (--(*stsz)));
    return temp;
}

void treedelete(PATHNODE root)
{
    unsigned int stsz = 1;
    PATHNODE *stack = malloc(sizeof(PATHNODE));
    PATHNODE node = *stack = root;


    while (stsz) {
        if (node->child[0])
            spush(&stack, &stsz, node->child[0]);
        if (node->child[1])
            spush(&stack, &stsz, node->child[1]);
        free(node);
        node = spop(&stack, &stsz);
    }
}


/*build_search_tree построение поискового дерева
 * используя префикс коды в таблице*/
PATHNODE build_search_tree(CODETABLE table)
{
	char buf[50] = {0};
	PATHNODE root = malloc(sizeof(struct pathnode));
	root->child[0] = root->child[1] = NULL;
	PATHNODE allocator = NULL;
	PATHNODE tracer = NULL;
	for (int i = 0; i < table->distcharc; ++i) {
		strcpy(buf, table->codes[i].prefixc);	
		tracer = root;
		for (int j = 0; buf[j] != 0; ++j) {
			if (tracer->child[buf[j] - 48] == NULL) {
				allocator = malloc(sizeof(struct pathnode));	
				allocator->child[0] = allocator->child[1] = NULL;
				tracer->child[buf[j] - 48] = allocator;
			}

			tracer = tracer->child[buf[j] - 48];
		}
		tracer->value = table->codes[i].value;
	}
	return root;
}

\end{verbatim}

Ознакомиться с кодом можно по \href{https://github.com/bobs4462/compression_algorithms}{ссылке}


\end{document}

